###############
##### Plotando fronteira de decisão não-linear
###############

### from op.minimize

from numpy import array, linspace, zeros , exp, insert, dot
import matplotlib.pyplot as plt

#"""    ##copy your weights here!!!
theta = [array([[  4.2979349 ,  -6.26665591,  -0.25503875],
       [ 13.16160398, -15.79430604, -10.62946399],
       [  6.75753338,   7.81641792,  18.09648811],
       [ -4.01868669, -11.01347846,  -0.48298159],
       [ -0.57664447, -14.49258485,   3.24135759],
       [ -2.77791027,  16.99008237,   4.33573443],
       [ -3.17154167,  -2.66652823,   6.008349  ],
       [ -3.14250869,  -9.04031558,  -7.08794018],
       [ -1.65880974,  20.14102086,  18.9027695 ],
       [  7.86585063,  -9.36292461,   8.46696312]]), array([[  2.37951329,   3.07257377, -15.33649522,  -6.47137092,
         12.19315092,   8.25834482,   7.41841929,   9.2521718 ,
          5.5417762 ,   9.69786383, -14.68367899],
       [ -5.70737748,  -6.633068  ,   3.29537216,  11.38222652,
         10.01979472,  -0.75496266,  -3.29409033,   1.77063745,
         -6.30976934,  -2.32325886,   1.41610584],
       [  2.52928324,  -2.69622176,  -9.57656823,   0.92216872,
          1.45928933,   3.2154925 ,  -0.46346709,   5.14981685,
         -1.04529592,   7.46243479,  -8.64727629],
       [ -2.26662878,   4.15439962,  -5.7819482 ,  20.44864577,
        -10.12909891,   8.5453574 ,  -0.32621849, -18.67354117,
          5.51107025,  -5.71654511,  -3.40663764],
       [  3.20506373,   7.56230101,  -9.64950174,  -2.64798129,
          7.7992031 ,   4.31032632,  -8.27484102,  -5.32446334,
         -3.58682195,  16.87380483,  -5.54283589],
       [ -4.38573272,  -3.77576032,  -1.67101593, -18.18343834,
          8.86533376,   5.32106267,  17.96638212,  -0.32592602,
         10.69940955,  17.30224545,   2.78342575],
       [ -2.25645592,  -1.64378817,  -3.09236827,   6.10842414,
          6.44417756,  -0.38918912,  -2.12979795,  -1.39892391,
         14.25158402,   3.65811019,  -5.06369932]]), array([[  0.45600413, -21.81916718,  -9.44744338, -14.48991007,
         17.5816489 ,  41.31887382, -29.80999432, -16.0656014 ]])]

#"""
# theta with regularization = 0.0001
"""
theta = [array([[-1.26461662, -3.49735046, -0.83527465],
       [ 1.40952845,  1.51487319,  3.79168859],
       [-1.29945449, -2.72533311, -0.29912826],
       [ 0.75197762, -1.51147822, -0.47078067],
       [-0.19646757,  0.95763895,  0.37910422],
       [-0.08708984,  1.20962039,  0.49159232],
       [-2.98058639, -1.24743171,  4.47661453],
       [-1.44261374,  2.06910423, -1.79487585],
       [-1.25620429,  1.2997648 , -1.76777865],
       [ 2.13994718, -3.33198166, -1.77375688]]), array([[ 4.64220152e-02, -1.11838850e+00,  1.74435691e+00,
        -8.24291046e-01, -1.32014196e-01,  3.88488063e-01,
         5.46492670e-01, -1.53913246e+00, -7.67627510e-01,
        -7.01122248e-01,  2.16276654e-01],
       [-3.84733186e-01,  2.46448479e+00, -3.75691257e+00,
         2.26703897e+00,  9.58813453e-01, -8.60558164e-01,
        -1.21108625e+00,  3.13542446e+00,  1.90854703e+00,
         1.85223655e+00, -8.68879212e-01],
       [-2.86326856e-01, -5.67152209e-01,  7.89828040e-01,
        -3.47189376e-01,  9.64529376e-02, -2.51308989e-01,
        -2.16958592e-01, -1.29486957e+00, -7.56438898e-01,
        -6.08711451e-01,  9.06542788e-01],
       [ 1.33462278e-01, -3.74927418e-02,  2.43262102e-01,
         1.36736366e-02,  1.45363133e-01,  6.10374696e-03,
         2.90430463e-02, -2.53935554e-01, -1.39253901e-01,
        -1.23256473e-01,  3.49308627e-01],
       [-1.92605831e-02, -1.95032462e-01,  3.56985947e-01,
        -1.68409935e-02,  1.16214193e-01, -6.63556129e-02,
         4.10235591e-04, -3.35400837e-01, -3.17496131e-01,
        -2.31395570e-01,  3.56356920e-01],
       [ 7.36035605e-02, -1.59704081e-02,  2.84539059e-01,
         1.50349072e-02,  1.79030633e-01,  4.50360513e-03,
         2.32719549e-02, -1.93382546e-01, -1.31730325e-01,
        -1.00157344e-01,  2.84764886e-01],
       [-7.48962195e-01,  1.38721449e-01, -5.45819102e-02,
         2.89114582e-01, -2.01889281e+00,  7.68434057e-01,
         9.98639543e-01,  4.40257121e+00,  2.38691265e+00,
         1.39828449e+00, -4.12170889e+00]]), array([[-0.04931184,  2.65240244, -6.54589811,  1.61039243,  0.57381897,
         0.774867  ,  0.49307061, -7.78848603]])]
"""

# Plotando fronteira de decisão
x1s = linspace(-1,1.5,50)
x2s = linspace(-1,1.5,50)
z= zeros((len(x1s),len(x2s)))

#y = h(x) = 1/(1+exp(- z))
#z = theta.T * x

def sigmoid(z, derivative=False):
    sig = 1 / (1 + exp(-z))
    if derivative:
        return z * (1 - z)
    return sig

def net_z_output(X, W, l, activation_func=sigmoid):
    Z = []
    A = [X.reshape(-1)]  # Ensure it's a flat vector
    AWB = [insert(X, 0, 1)]  # Add bias term to input

    for i in range(l - 1):
        z = dot(W[i], AWB[i])
        Z.append(z)
        a = activation_func(z)
        A.append(a)
        AWB.append(insert(a, 0, 1))  # Add bias for next layer

    return  Z[-1]


for i in range(len(x1s)):
    for j in range(len(x2s)):
        x = array([x1s[i], x2s[j]]).reshape(2,-1)
        z[i,j] = net_z_output(x,theta,4)  # saida do modelo antes de aplicar a função sigmoide - substituir aqui teu código
plt.contour(x1s,x2s,z.T,0)
plt.xlabel("x1")
plt.ylabel("x2")
plt.legend(loc=0)
plt.show()