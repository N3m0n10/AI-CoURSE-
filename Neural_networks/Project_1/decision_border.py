###############
##### Plotando fronteira de decisão não-linear
###############

### from op.minimize

from numpy import array, linspace, zeros , exp, insert, dot
import matplotlib.pyplot as plt

#"""
theta = [array([[ -0.23357722,   2.31939449,   3.84737183],
       [  5.47444283,  10.01908269,  16.22609267],
       [ -5.28343354,  -0.19998228,  -0.28308919],
       [  4.1086489 ,  -6.15897004,  -2.1029299 ],
       [ -2.51850382,  15.63778804,   4.41521329],
       [ -8.34023549,   2.35298577,  12.11993961],
       [  6.39377788,   7.30775644,  -5.41300155],
       [ -7.61961076,   9.55333819,  -1.56298011],
       [ -0.09315695,  -2.68757902,  -1.0913084 ],
       [  5.27578282, -19.78414188,   1.63022724]]), array([[  1.71499238,  -1.22587934,  -5.88339196,   0.13434031,
          3.72310062,   1.22153812,  -0.24027193,  -7.33902209,
          3.87285269,   3.77986328,   0.81864014],
       [  1.86917611,   0.90911745,  -9.28883553,  -0.62395098,
         -0.45975282,   8.29343199,   2.59494893,  -3.58092006,
          4.01609061,  -0.28079545,   0.81393362],
       [  0.252247  ,   1.2021972 ,   2.94744109,   0.98039052,
        -12.04586539,   5.13023861,   3.37495282,  -0.03143588,
          3.12191006,  -1.49103539,  -5.8367845 ],
       [  0.59262234,  -0.87308495,  -3.76391664,   0.70550708,
         -1.69563759,   2.57710518,   1.75985544,  -3.11090873,
          3.2127056 ,   1.03963521,   3.31137399],
       [ -1.62936083,   0.9069913 ,   6.58175534,   0.36191935,
         -2.11161943,  -8.24803135,  -0.08048653,   6.48609884,
         -2.28846949,  -2.78099814,   0.17444402],
       [  2.94139975,   1.97328519,   1.46998549,  -1.70857029,
         14.26275739,  -4.95363736, -13.96983409,   0.90912162,
         -9.82070633,   8.19481561,  12.48065213],
       [  2.12451682,  -0.24547786,  -2.45005974,  -0.19006795,
         -2.34575398,   3.60389715,   0.18569074,  -5.88785083,
          5.69234205,   2.82316697,   3.34103402]]), array([[-1.37615263, -3.15239609, -9.39038145,  2.05740907, -3.14999284,
         2.09091099,  4.04038087, -5.07563873]])]
#"""
# theta with regularization = 0.0001
"""
theta = [array([[-1.26461662, -3.49735046, -0.83527465],
       [ 1.40952845,  1.51487319,  3.79168859],
       [-1.29945449, -2.72533311, -0.29912826],
       [ 0.75197762, -1.51147822, -0.47078067],
       [-0.19646757,  0.95763895,  0.37910422],
       [-0.08708984,  1.20962039,  0.49159232],
       [-2.98058639, -1.24743171,  4.47661453],
       [-1.44261374,  2.06910423, -1.79487585],
       [-1.25620429,  1.2997648 , -1.76777865],
       [ 2.13994718, -3.33198166, -1.77375688]]), array([[ 4.64220152e-02, -1.11838850e+00,  1.74435691e+00,
        -8.24291046e-01, -1.32014196e-01,  3.88488063e-01,
         5.46492670e-01, -1.53913246e+00, -7.67627510e-01,
        -7.01122248e-01,  2.16276654e-01],
       [-3.84733186e-01,  2.46448479e+00, -3.75691257e+00,
         2.26703897e+00,  9.58813453e-01, -8.60558164e-01,
        -1.21108625e+00,  3.13542446e+00,  1.90854703e+00,
         1.85223655e+00, -8.68879212e-01],
       [-2.86326856e-01, -5.67152209e-01,  7.89828040e-01,
        -3.47189376e-01,  9.64529376e-02, -2.51308989e-01,
        -2.16958592e-01, -1.29486957e+00, -7.56438898e-01,
        -6.08711451e-01,  9.06542788e-01],
       [ 1.33462278e-01, -3.74927418e-02,  2.43262102e-01,
         1.36736366e-02,  1.45363133e-01,  6.10374696e-03,
         2.90430463e-02, -2.53935554e-01, -1.39253901e-01,
        -1.23256473e-01,  3.49308627e-01],
       [-1.92605831e-02, -1.95032462e-01,  3.56985947e-01,
        -1.68409935e-02,  1.16214193e-01, -6.63556129e-02,
         4.10235591e-04, -3.35400837e-01, -3.17496131e-01,
        -2.31395570e-01,  3.56356920e-01],
       [ 7.36035605e-02, -1.59704081e-02,  2.84539059e-01,
         1.50349072e-02,  1.79030633e-01,  4.50360513e-03,
         2.32719549e-02, -1.93382546e-01, -1.31730325e-01,
        -1.00157344e-01,  2.84764886e-01],
       [-7.48962195e-01,  1.38721449e-01, -5.45819102e-02,
         2.89114582e-01, -2.01889281e+00,  7.68434057e-01,
         9.98639543e-01,  4.40257121e+00,  2.38691265e+00,
         1.39828449e+00, -4.12170889e+00]]), array([[-0.04931184,  2.65240244, -6.54589811,  1.61039243,  0.57381897,
         0.774867  ,  0.49307061, -7.78848603]])]
"""

# Plotando fronteira de decisão
x1s = linspace(-1,1.5,50)
x2s = linspace(-1,1.5,50)
z= zeros((len(x1s),len(x2s)))

#y = h(x) = 1/(1+exp(- z))
#z = theta.T * x

def sigmoid(z, derivative=False):
    sig = 1 / (1 + exp(-z))
    if derivative:
        return z * (1 - z)
    return sig

def net_z_output(X, W, l, activation_func=sigmoid):
    Z = []
    A = [X.reshape(-1)]  # Ensure it's a flat vector
    AWB = [insert(X, 0, 1)]  # Add bias term to input

    for i in range(l - 1):
        z = dot(W[i], AWB[i])
        Z.append(z)
        a = activation_func(z)
        A.append(a)
        AWB.append(insert(a, 0, 1))  # Add bias for next layer

    return  Z[-1]


for i in range(len(x1s)):
    for j in range(len(x2s)):
        x = array([x1s[i], x2s[j]]).reshape(2,-1)
        z[i,j] = net_z_output(x,theta,4)  # saida do modelo antes de aplicar a função sigmoide - substituir aqui teu código
plt.contour(x1s,x2s,z.T,0)
plt.xlabel("x1")
plt.ylabel("x2")
plt.legend(loc=0)
plt.show()