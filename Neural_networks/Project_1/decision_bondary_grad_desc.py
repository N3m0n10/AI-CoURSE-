###############
##### Plotando fronteira de decisão não-linear
###############

from numpy import array, linspace, zeros , exp, insert, dot
import matplotlib.pyplot as plt

theta = [array([[-0.56998685, -1.4184532 ,  0.03146302],
       [ 0.53058958, -0.74208894, -0.85708959],
       [ 0.66780571,  0.12210226, -0.68018111],
       [ 0.22992071,  0.1013868 , -0.43620404],
       [-0.06305202,  0.07299161,  0.35073773],
       [-0.07509586,  0.13971607, -1.43764651],
       [-0.25041754,  0.33821941, -0.94825314],
       [ 0.81480386, -0.0073117 ,  0.33800757],
       [ 0.71513949, -0.09064582, -0.21503919],
       [ 1.74472992, -0.41737948, -0.80582246],
       [-1.19571506, -0.12915195, -0.49575365],
       [ 0.86063066, -0.31471632,  0.56755938],
       [-0.65876117, -0.17250249,  0.05933509],
       [ 0.34933696,  0.47325041, -0.77704287],
       [-0.76201123,  0.24476812, -0.32671242]]), array([[-2.59142339e-01, -1.14042589e-02,  5.35828250e-02,
        -3.06459342e-01,  5.85479622e-02, -4.25330207e-02,
         2.80481364e-01, -6.39286566e-02, -3.36865124e-01,
         2.34829831e-01,  1.93104313e-01,  3.04515540e-01,
        -3.51706581e-01, -2.30664481e-01, -9.03664312e-02,
        -5.10172630e-02],
       [ 1.15036998e-02, -3.13962998e-01,  3.41714188e-01,
        -1.53437128e-01,  5.95178898e-02,  7.27992037e-02,
        -1.70954666e-01,  3.23508403e-01,  6.36835508e-02,
         2.99491775e-01, -2.47882862e-01,  3.41932758e-01,
        -1.41378667e-01, -1.93535003e-01, -2.13334275e-01,
         1.57615846e-01],
       [ 5.41925474e-02,  4.45928846e-01, -1.41325070e-01,
         8.70168927e-02,  1.20646686e-01,  3.61799998e-01,
         5.18007620e-01, -2.47703340e-01, -7.71730088e-02,
        -3.19717118e-01,  2.60062377e-01,  3.06470655e-04,
         1.56777395e-01, -7.13449626e-02, -3.22724674e-02,
         5.06837280e-01],
       [ 4.37939299e-01, -2.20008413e-01,  4.47116039e-02,
        -2.27274106e-01,  9.62571014e-02,  3.47921526e-02,
        -1.61990030e-01, -2.51383834e-01, -4.35811982e-02,
        -2.43547928e-01, -2.57105737e-01,  9.68582044e-02,
         2.67939499e-01, -4.69168386e-01,  5.80462568e-03,
        -4.29144801e-01],
       [-2.28384599e-01, -1.43833677e-01, -7.59103631e-02,
         4.26297242e-02, -2.73848729e-01, -8.90603658e-03,
         1.69984793e-01, -1.25829110e-01, -9.70084407e-02,
        -1.37573129e-01,  1.42592434e-02,  1.21107696e-01,
        -8.35957616e-02,  4.98914686e-02, -4.77143701e-01,
        -1.62014100e-01],
       [ 1.73327019e-02,  4.86440955e-02,  5.84403923e-02,
        -5.37563222e-02, -4.12353351e-01,  6.96211643e-02,
        -3.62251861e-01,  3.01833829e-02, -2.85383754e-01,
         4.91449336e-01,  7.90997928e-02, -4.21185358e-01,
         1.79422977e-01,  1.20358143e-01,  4.50174984e-01,
         3.62471402e-01],
       [-5.78702319e-02,  6.70482296e-02, -2.85393219e-02,
        -3.38298548e-01,  3.94971890e-01, -3.44531081e-02,
        -6.40732968e-02,  1.83178546e-01, -5.59219619e-01,
        -1.30942475e-01, -3.18979796e-01,  2.57453979e-01,
        -5.75609532e-02,  2.06584587e-01,  1.95711020e-02,
        -4.95037729e-02],
       [-1.30529260e-01,  3.43195849e-01,  3.73327841e-01,
         3.86866341e-01, -4.07893346e-01,  5.33311537e-03,
         3.58402015e-01, -3.85149740e-02, -3.02184844e-01,
         1.58885499e-01, -2.15243123e-01,  3.09447836e-01,
         6.16327019e-02,  6.70620128e-01, -1.64933956e-02,
         4.69563492e-02],
       [-1.21864890e-01, -4.20659714e-01, -2.22912908e-01,
        -3.38929361e-01, -1.33535305e-01,  6.95891241e-02,
        -8.04826655e-02,  2.54210609e-01, -7.01725877e-02,
         1.98449995e-01,  3.05935769e-01, -2.66373485e-02,
         1.35473680e-01,  1.58794679e-01, -1.08958456e-02,
        -2.07608933e-02],
       [ 4.85371459e-02, -3.41129848e-01, -3.27403295e-01,
        -3.15806359e-03,  2.30912812e-01, -6.95581134e-02,
         8.38080239e-02,  3.30619704e-01,  8.65636330e-02,
        -1.49647010e-01,  2.97283046e-01,  1.56073730e-01,
        -1.76486164e-01,  1.18906127e-01,  2.70673418e-01,
         1.47972748e-01],
       [-2.71657695e-01, -3.85379329e-01,  2.07706824e-01,
         9.65884626e-02, -1.89218770e-01,  1.58391704e-01,
        -1.77239037e-01,  3.66806579e-01, -3.34153807e-01,
        -1.31222553e-01,  2.71214124e-01, -8.05376749e-02,
        -1.03455119e-01, -2.27734623e-01, -1.21023531e-01,
         1.14960778e-01],
       [ 2.91968369e-01, -4.64103744e-02, -4.19029183e-02,
        -1.74247179e-01,  5.07870680e-01,  2.47748731e-01,
         3.07908138e-01, -9.17028810e-02,  1.69775672e-02,
         1.34043837e-01, -2.13533584e-01,  8.24419918e-02,
        -4.70964995e-01,  3.73354398e-02, -2.04995541e-01,
         5.30744977e-01],
       [ 9.98394556e-03,  1.04784368e-01,  1.43095035e-01,
        -4.02749213e-02,  1.48808392e-01,  3.91805322e-02,
         9.81898970e-02,  1.52317379e-01, -9.50655456e-03,
         7.33786001e-02,  3.77223725e-01, -3.48013850e-01,
        -2.47075030e-01, -1.50676308e-01, -1.27109374e-01,
         4.30876831e-01],
       [ 4.42604580e-01,  2.63294576e-01, -4.00848054e-01,
         2.48053645e-01, -1.70434651e-01,  2.63525501e-01,
        -5.70660756e-02,  2.29492651e-01, -2.83340697e-01,
        -3.07448153e-01,  1.69551881e-01,  1.89997655e-01,
        -2.31459671e-01, -3.85889896e-02, -9.72458269e-03,
         1.01373996e-01],
       [ 1.56901945e-01, -6.89914215e-01,  7.41119887e-02,
        -2.38069379e-01, -5.09104219e-01, -2.50781309e-02,
         1.84888062e-01, -3.50589493e-01, -7.69170527e-02,
         9.92577574e-01,  8.93491503e-02, -2.74817524e-01,
        -1.76772184e-01, -8.90273174e-02,  9.81158377e-03,
        -4.28769947e-01]]), array([[-0.04924577, -0.24802053, -0.02847161, -0.01758691, -0.45143718,
         0.20342804,  0.236718  , -0.78704408, -0.07466934, -0.10663647,
        -0.18505792,  0.21478529,  0.45339203,  0.12463029, -0.09332818,
         0.46707524]])]

# Plotando fronteira de decisão
x1s = linspace(-1,1.5,50)
x2s = linspace(-1,1.5,50)
z= zeros((len(x1s),len(x2s)))

#y = h(x) = 1/(1+exp(- z))
#z = theta.T * x

def sigmoid(z, derivative=False):
    sig = 1 / (1 + exp(-z))
    if derivative:
        return z * (1 - z)
    return sig

def net_z_output(X, W, l, activation_func=sigmoid):
    Z = []
    A = [X.reshape(-1)]  # Ensure it's a flat vector
    AWB = [insert(X, 0, 1)]  # Add bias term to input

    for i in range(l - 1):
        z = dot(W[i], AWB[i])
        Z.append(z)
        a = activation_func(z)
        A.append(a)
        AWB.append(insert(a, 0, 1))  # Add bias for next layer

    return  Z[-1]


for i in range(len(x1s)):
    for j in range(len(x2s)):
        x = array([x1s[i], x2s[j]]).reshape(2,-1)
        z[i,j] = net_z_output(x,theta,len(theta)+1)  # (x,theta,n_layers)
plt.contour(x1s,x2s,z.T,0)
plt.xlabel("x1")
plt.ylabel("x2")
plt.show()