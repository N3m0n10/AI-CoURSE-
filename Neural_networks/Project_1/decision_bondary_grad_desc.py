###############
##### Plotando fronteira de decisão não-linear
###############

from numpy import array, linspace, zeros , exp, insert, dot
import matplotlib.pyplot as plt

theta = [array([[-1.33362496e+00,  1.16181256e+00, -2.42071856e+00],
       [ 6.55904223e-01,  1.24068989e-01, -8.23288931e-01],
       [-2.22198996e-01, -9.20140199e-01,  8.11960379e-02],
       [ 7.71355272e-01,  1.57283748e-02,  4.49961796e-01],
       [ 3.94872443e-01,  3.45876684e-01,  2.12235958e-01],
       [ 6.57773028e-01, -2.71255558e-03,  4.64364280e-02],
       [-4.70205504e-01,  1.58071697e-01, -1.16352886e-01],
       [-4.97964250e-01, -2.00264830e-01,  2.38051853e-01],
       [ 3.68021990e-01, -4.77535592e-01,  2.94669775e-01],
       [-4.37476976e-01, -8.99259713e-02, -5.79217843e-01],
       [-5.70364733e-01,  2.05584141e-02, -2.21306622e-01],
       [ 6.15042535e-01,  2.46371531e-02,  3.80347128e-01],
       [ 1.33995611e+00,  7.05454315e-01,  4.67920876e+00],
       [-2.62272493e-01,  6.90458989e-01,  2.76939021e-01],
       [-8.51642000e-01, -1.43728830e-01, -2.09711599e-01],
       [-1.74163126e+00,  1.42641301e+00,  2.01389445e+00],
       [-2.54721468e-01, -1.54507775e-01, -2.76839201e-01],
       [-7.36153243e-01, -1.43874427e+00,  5.36660742e-01],
       [ 4.59837219e-01, -4.59719937e-01, -5.30069394e-02],
       [-1.73300298e+00, -4.46207749e+00, -2.47523473e-01],
       [ 1.84965577e+00,  2.34632224e+00, -2.44115008e+00],
       [ 1.39659760e+00, -1.94836465e+00, -5.99199708e-01],
       [-1.47857419e-01,  7.57101770e-01,  3.63619305e-01],
       [ 1.30033186e+00, -2.69816481e-02,  3.15934926e-01],
       [ 9.83518302e-01,  1.95488851e+00, -1.13522545e+00],
       [ 1.03466531e+00, -1.44187067e+00, -3.36413032e-01],
       [-2.99931053e-01,  9.82357172e-02,  3.03503590e-01],
       [-4.31328664e-01, -1.14613806e-01,  3.57016236e-01],
       [-2.36663384e-02, -2.71725961e-01, -6.98095985e-01],
       [ 4.22370407e-02, -1.79028954e-01, -9.88805769e-02],
       [ 1.03950274e+00,  2.34821260e-01, -1.10213989e+00],
       [ 3.12519901e-01,  2.83505497e-01, -8.35146660e-03],
       [-9.37921064e-02, -4.44688433e-01,  4.25949173e-01],
       [-6.26999374e-01,  1.06355608e-01, -1.69764661e+00],
       [-1.45990903e+00, -2.11660977e+00, -3.65098816e+00],
       [ 7.54768985e-01,  1.95695433e-01, -4.79466228e-01],
       [-6.78888021e-01,  8.96297316e-02,  2.35337751e-01],
       [ 1.36905387e+00,  7.27959841e-02,  1.46245535e-01],
       [-3.02346866e+00,  5.54851996e+00,  3.10310661e+00],
       [ 3.32264893e-01, -3.85154120e-01, -2.38255277e-01],
       [-5.14558220e-01, -2.49244424e-01, -1.76360090e-02],
       [-6.04273260e-01,  5.31505905e-01, -8.35553258e-03],
       [-1.24392792e-01,  1.82548391e-01,  4.21024426e-01],
       [-1.68167443e+00, -2.12154952e+00,  2.16749434e+00],
       [ 1.32968298e+00, -1.99157328e-01, -2.55524876e-01],
       [-1.60043646e-02,  1.05464334e+00, -3.96981746e-01],
       [-1.11587253e+00,  4.43922939e-01, -3.06725524e-01],
       [ 5.97202235e-02,  2.11655398e-01, -7.50815524e-01],
       [-2.50493776e-01, -2.42300035e-01,  7.50789464e-01],
       [ 4.37804138e-01,  2.99976331e-01, -1.74022860e-01]]), array([[-2.69320193e-01, -2.19421602e+00,  1.66541940e-01,
        -4.50434392e-01,  1.61126541e-02, -1.31858162e-01,
        -1.27494117e-01, -6.76159034e-02,  9.63572120e-02,
         3.46334124e-01, -4.72093713e-01, -6.17645073e-02,
         5.78777046e-02,  4.91098445e+00, -3.64546894e-01,
        -9.42425670e-02, -1.95507497e+00,  6.30614880e-02,
        -1.04963494e+00, -1.48125064e-01, -3.88879371e+00,
         3.05764271e+00,  1.42633580e+00, -4.22475543e-02,
        -1.79133896e-01,  1.33572719e+00,  7.96046706e-01,
         1.39600504e-01, -1.43221805e-01, -3.34397687e-01,
        -1.91635283e-01,  3.70717518e-01, -2.70522599e-03,
        -1.21891705e-01, -1.06474070e+00, -3.57369217e+00,
        -7.23496896e-02, -1.96590038e-02, -1.07850811e-01,
        -6.99595558e+00, -2.33103186e-01, -8.75543372e-02,
        -3.11231354e-01, -8.18375994e-02, -2.65215685e+00,
        -2.67906970e-01, -2.93594919e-02, -2.09591910e-01,
        -1.67969054e-01, -3.04347876e-01, -9.02765913e-02]])]
# Plotando fronteira de decisão
x1s = linspace(-1,1.5,50)
x2s = linspace(-1,1.5,50)
z= zeros((len(x1s),len(x2s)))

#y = h(x) = 1/(1+exp(- z))
#z = theta.T * x

def sigmoid(z, derivative=False):
    sig = 1 / (1 + exp(-z))
    if derivative:
        return z * (1 - z)
    return sig

def net_z_output(X, W, l, activation_func=sigmoid):
    Z = []
    A = [X.reshape(-1)]  # Ensure it's a flat vector
    AWB = [insert(X, 0, 1)]  # Add bias term to input

    for i in range(l - 1):
        z = dot(W[i], AWB[i])
        Z.append(z)
        a = activation_func(z)
        A.append(a)
        AWB.append(insert(a, 0, 1))  # Add bias for next layer

    return  Z[-1]


for i in range(len(x1s)):
    for j in range(len(x2s)):
        x = array([x1s[i], x2s[j]]).reshape(2,-1)
        z[i,j] = net_z_output(x,theta,len(theta)+1)  # (x,theta,n_layers)
plt.contour(x1s,x2s,z.T,0)
plt.xlabel("x1")
plt.ylabel("x2")
plt.show()