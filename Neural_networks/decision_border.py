###############
##### Plotando fronteira de decisão não-linear
###############

import numpy as np
import matplotlib.pyplot as plt

theta = [np.array([[ -0.23357722,   2.31939449,   3.84737183],
       [  5.47444283,  10.01908269,  16.22609267],
       [ -5.28343354,  -0.19998228,  -0.28308919],
       [  4.1086489 ,  -6.15897004,  -2.1029299 ],
       [ -2.51850382,  15.63778804,   4.41521329],
       [ -8.34023549,   2.35298577,  12.11993961],
       [  6.39377788,   7.30775644,  -5.41300155],
       [ -7.61961076,   9.55333819,  -1.56298011],
       [ -0.09315695,  -2.68757902,  -1.0913084 ],
       [  5.27578282, -19.78414188,   1.63022724]]), np.array([[  1.71499238,  -1.22587934,  -5.88339196,   0.13434031,
          3.72310062,   1.22153812,  -0.24027193,  -7.33902209,
          3.87285269,   3.77986328,   0.81864014],
       [  1.86917611,   0.90911745,  -9.28883553,  -0.62395098,
         -0.45975282,   8.29343199,   2.59494893,  -3.58092006,
          4.01609061,  -0.28079545,   0.81393362],
       [  0.252247  ,   1.2021972 ,   2.94744109,   0.98039052,
        -12.04586539,   5.13023861,   3.37495282,  -0.03143588,
          3.12191006,  -1.49103539,  -5.8367845 ],
       [  0.59262234,  -0.87308495,  -3.76391664,   0.70550708,
         -1.69563759,   2.57710518,   1.75985544,  -3.11090873,
          3.2127056 ,   1.03963521,   3.31137399],
       [ -1.62936083,   0.9069913 ,   6.58175534,   0.36191935,
         -2.11161943,  -8.24803135,  -0.08048653,   6.48609884,
         -2.28846949,  -2.78099814,   0.17444402],
       [  2.94139975,   1.97328519,   1.46998549,  -1.70857029,
         14.26275739,  -4.95363736, -13.96983409,   0.90912162,
         -9.82070633,   8.19481561,  12.48065213],
       [  2.12451682,  -0.24547786,  -2.45005974,  -0.19006795,
         -2.34575398,   3.60389715,   0.18569074,  -5.88785083,
          5.69234205,   2.82316697,   3.34103402]]), np.array([[-1.37615263, -3.15239609, -9.39038145,  2.05740907, -3.14999284,
         2.09091099,  4.04038087, -5.07563873]])]


# Plotando fronteira de decisão
x1s = np.linspace(-1,1.5,50)
x2s = np.linspace(-1,1.5,50)
z=np.zeros((len(x1s),len(x2s)))

#y = h(x) = 1/(1+exp(- z))
#z = theta.T * x

def sigmoid(z, derivative=False):
    sig = 1 / (1 + np.exp(-z))
    if derivative:
        return z * (1 - z)
    return sig

def net_z_output(X, W, l, activation_func=sigmoid):
    Z = []
    A = [X.reshape(-1)]  # Ensure it's a flat vector
    AWB = [np.insert(X, 0, 1)]  # Add bias term to input

    for i in range(l - 1):
        z = np.dot(W[i], AWB[i])
        Z.append(z)
        a = activation_func(z)
        A.append(a)
        AWB.append(np.insert(a, 0, 1))  # Add bias for next layer

    return  Z[-1]


for i in range(len(x1s)):
    for j in range(len(x2s)):
        x = np.array([x1s[i], x2s[j]]).reshape(2,-1)
        z[i,j] = net_z_output(x,theta,4)  # saida do modelo antes de aplicar a função sigmoide - substituir aqui teu código
plt.contour(x1s,x2s,z.T,0)
plt.xlabel("x1")
plt.ylabel("x2")
plt.legend(loc=0)
plt.show()